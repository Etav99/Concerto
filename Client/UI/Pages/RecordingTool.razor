@page "/recorder"
@using Concerto.Client.Services;
@using Concerto.Shared.Models.Dto;
@inject IJSRuntime JS
@inject IStorageService StorageService
@implements IAsyncDisposable

<style>
	.container {
		height: 100%;
		display: grid;
		grid-template-columns: 1fr;
		grid-template-rows: min-content 1fr;
		gap: 0px 0px;
		grid-template-areas:
			"buttons"
			"preview";
	}

	.buttons {
		grid-area: buttons;
	}

	.preview {
		grid-area: preview;
	}

	.canvas-container {
		overflow: hidden;
	}

	.canvas-container > canvas {
		object-fit: contain;
		max-width: 100%;
		height: calc(100% - 44px);
	}
</style>

@if(LayoutState.IsMobile)
{
	<div class="d-flex align-center justify-center" style="height: 100%">
		<MudText role="alert" Style="text-align: center; margin:auto;" Typo="Typo.h4">Feature unavailable on mobile devices</MudText>
	</div>
}
else
{
		<div class="container pa-1">
			<div class="buttons d-flex py-1 ">

			@*
				<MudFileUpload T="IBrowserFile" Accept="video/*" Class="mt-0">
					<ButtonTemplate>
						<MudButton HtmlTag="label"
						   Variant="Variant.Filled"
						   Color="Color.Info"
						   DisableElevation="true"
						   StartIcon="@Icons.Material.Filled.CloudUpload"
				 for="@context">
							Upload recording
						</MudButton>
					</ButtonTemplate>
				</MudFileUpload>
				*@

				@if (!isRecording)
				{
					<MudButton StartIcon="@Icons.Material.Filled.FiberManualRecord" IconColor="Color.Error" Color="Color.Success" Variant="Variant.Filled" DisableElevation="true" OnClick="StartRecording">
						Start recording
					</MudButton>
				}
				else
				{
					<MudButton StartIcon="@Icons.Material.Filled.Stop" IconColor="Color.Default" Color="Color.Error" Variant="Variant.Filled" DisableElevation="true" OnClick="StopRecording">
						Stop recording
					</MudButton>
				}

				<div class="d-flex ">
					<MudIcon Style="align-self: center" Icon="@Icons.Material.Filled.Mic" />
					<select style="align-self: stretch; flex-shrink: 1;"  onclick="@(() => FetchMediaInputs())" @bind="SelectedAudioInputId">
						@foreach (var input in audioInputs)
						{
							<option value="@input.Id">@input.Name</option>
						}
					@if (!audioInputs.Any())
					{
						<option value="@string.Empty">None</option>
					}
					</select>
				</div>

				<div class="d-flex ">
					<MudIcon Style="align-self: center" Icon="@Icons.Material.Filled.CameraAlt" />
					<select style="align-self: stretch; flex-shrink: 1;" onclick="@(() => FetchMediaInputs())" @bind="SelectedVideoInputId">
						@foreach (var input in videoInputs)
						{
							<option value="@input.Id">@input.Name</option>
						}
						@if (!videoInputs.Any())
						{
							<option value="@string.Empty">None</option>
						}
					</select>
				</div>
			</div>


			<div id="recorderPreview" class="preview canvas-container d-flex align-center justify-center py-1">
			</div>

		</div>
}


@code {
	[CascadingParameter] LayoutState LayoutState { get; set; } = LayoutState.Default;

	private (string Name, string Id)[] audioInputs = Array.Empty<(string Name, string Id)>();
	private (string Name, string Id)[] videoInputs = Array.Empty<(string Name, string Id)>();

	private string _selectedAudioInputId = string.Empty;
	private string _selectedVideoInputId = string.Empty;

	private string SelectedAudioInputId
	{
		get { return _selectedAudioInputId; }
		set
		{
			_selectedAudioInputId = value;
			_recordingManager?.InvokeVoidAsync("setMicrophone", value).AndForget();
		}
	}

	private string SelectedVideoInputId
	{
		get { return _selectedVideoInputId; }
		set
		{
			_selectedVideoInputId = value;
			_recordingManager?.InvokeVoidAsync("setWebcam", value).AndForget();
		}
	}

	bool isRecording = false;

	private DotNetObjectReference<RecordingTool> _dotNetObjectReference = null!;
	IJSObjectReference? _recordingManager;

	class MediaDevices
	{
		public string[] Names { get; set; } = null!;
		public string[] Ids { get; set; } = null!;
	}

	protected override void OnInitialized()
	{
		_dotNetObjectReference = DotNetObjectReference.Create(this);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_recordingManager = await JS.InvokeAsync<IJSObjectReference>("initializeRecordingManager", "recorderPreview", _dotNetObjectReference);
			await FetchMediaInputs();
		}
	}


	private async Task FetchMediaInputs()
	{
		var audioDevices = await GetAudioInputs();
		var videoDevices = await GetVideoInputs();

		audioInputs = audioDevices.Names.Zip(audioDevices.Ids, (name, id) => (name, id)).ToArray();
		videoInputs = videoDevices.Names.Zip(videoDevices.Ids, (name, id) => (name, id)).ToArray();

		if (string.IsNullOrEmpty(SelectedAudioInputId) && audioInputs.Length > 0)
			SelectedAudioInputId = audioInputs[0].Id;

		if (string.IsNullOrEmpty(SelectedVideoInputId) && videoInputs.Length > 0)
			SelectedVideoInputId = videoInputs[0].Id;

		StateHasChanged();
    }


	private async Task SetVideoInput(ChangeEventArgs args)
	{
		if(_recordingManager is null) return;
		var value = args.Value?.ToString();
		await _recordingManager.InvokeVoidAsync("setWebcam", value);
	}

	private async Task SetAudioInput(ChangeEventArgs args)
	{
		if (_recordingManager is null) return;
		var value = args.Value?.ToString();
		await _recordingManager.InvokeVoidAsync("setMicrophone", value);
	}

	public async Task StartRecording()
	{
		if (_recordingManager is null) return;
		await _recordingManager.InvokeVoidAsync("startRecording");
	}
	
	public async Task StopRecording()
	{
		if (_recordingManager is null) return;
		await _recordingManager.InvokeVoidAsync("stopRecording");
	}

	[JSInvokable]
	public void RecordingStateChanged(bool state)
	{
		isRecording = state;
		StateHasChanged();
	}

	private async Task<MediaDevices> GetAudioInputs()
	{
		return await JS.InvokeAsync<MediaDevices>("getAudioInputs");
	}

	private async Task<MediaDevices> GetVideoInputs()
	{
		return await JS.InvokeAsync<MediaDevices>("getVideoInputs");
	}


	public async ValueTask DisposeAsync()
	{
		if (isRecording)
			await StopRecording();

		if (_recordingManager is not null)
			await _recordingManager.InvokeVoidAsync("dispose");

		_dotNetObjectReference?.Dispose();
	}

}