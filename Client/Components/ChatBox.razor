@using Concerto.Client.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Concerto.Shared.Extensions

@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication

@implements IDisposable
@inject IJSRuntime JsRuntime
@inject IChatService ChatService
@inject IUserService UserService
@inject AuthenticationStateProvider AuthenticationStateProvider

<MudStack Style="width: 100%; height:100%;">
	<MudPaper Class="pa-2 mb-2 mud-theme-primary" Square="true" Elevation="0">
		<MudStack Row="true" Justify="Justify.Center">
			<MudIcon Icon="@Icons.Material.Filled.Chat" />
			<MudText Align="Align.Center">@($"{(SelectedConversation == null ? null : ConversationName)}")</MudText>
			</MudStack>
	</MudPaper>

	<MudStack Reverse="true" Class="flex-grow-1" Justify="Justify.FlexStart" Style="overflow:auto;" id="stack">
			@if (SelectedConversation != null && ChatService.Messages.ContainsKey(SelectedConversation.Id))
			{
				foreach (var message in ChatService.Messages[SelectedConversation.Id])
				{
				<MudPaper Class="@(isSender(message.SenderId) ? "ml-4 mr-8 pa-2 mud-theme-secondary" : "mr-4 ml-8 pa-2 mud-theme-tertiary")"
					  Style="@(isSender(message.SenderId) ? "align-self: flex-end"  : "align-self: flex-start")"
					  Elevation="0">
						@message.Content
				</MudPaper>
				}
			}
	</MudStack>

	<MudStack Row="true" AlignItems="AlignItems.Stretch" Class="mx-4 mb-2">
		<MudTextField @bind-Value="MessageContent" Immediate="true" OnKeyPress="Enter" Label="Message" Variant="Variant.Outlined">></MudTextField>
		<MudButton OnClick="Send" StartIcon="@Icons.Material.Filled.Send" Color="Color.Primary" ButtonType="ButtonType.Button">Send</MudButton>
	</MudStack>
</MudStack>

@code {
	public string MessageContent { get; set; } = string.Empty;
	bool loading = true;

	[Parameter]
	public Dto.Conversation? SelectedConversation { get; set; }
	private string ConversationName { get; set; } = string.Empty;

	private bool isSender(long senderId) => senderId == UserService.UserId;

	protected override async Task OnInitializedAsync()
	{
		ChatService.OnMessageReceivedCallback += OnMessageReceivedCallback;
		await ChatService.ConnectToChatAsync();
		loading = true;
		await LoadSelectedConversation();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		await JsRuntime.InvokeAsync<string>("scrollToBottom", "messagesContainer");
	}

	private async Task Send()
	{
		if (ChatService.Connected && !string.IsNullOrEmpty(MessageContent) && SelectedConversation != null && SelectedConversation.Id > 0)
		{
			Dto.ChatMessage message = new Dto.ChatMessage { SenderId = UserService.UserId!.Value, ConversationId = SelectedConversation!.Id, SendTimestamp = DateTime.UtcNow, Content = MessageContent };
			await ChatService.SendChatMessageAsync(message);
			MessageContent = string.Empty;
			ShouldRender();
		}
	}

	private async Task Enter(KeyboardEventArgs e)
	{
		if (e.Code == "Enter" || e.Code == "NumpadEnter")
		{
			await Send();
		}
	}
	
	protected override async Task OnParametersSetAsync() {
		await LoadSelectedConversation();
	}

	public async Task ChangeConversation(Dto.Conversation conversation)
	{
		SelectedConversation = conversation;
		await LoadSelectedConversation();
	}

	private async Task LoadSelectedConversation()
	{
		if (SelectedConversation == null)
			return;
		await ChatService.LoadChatMessagesAsync(SelectedConversation.Id);
		GenerateConversationName();
		StateHasChanged();
	}
	
	private void OnMessageReceivedCallback(Dto.ChatMessage message)
	{
		StateHasChanged();
	}

	private void GenerateConversationName()
	{
		ConversationName = String.Join(", ", SelectedConversation?.Users?.Select(u => u.FullName) ?? Enumerable.Empty<string>());
	}

	public void Dispose() {
		ChatService.OnMessageReceivedCallback -= OnMessageReceivedCallback;
	}
}
