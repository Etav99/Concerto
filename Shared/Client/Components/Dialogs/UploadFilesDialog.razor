@using System.Net.Http.Headers
@using Concerto.Shared.Models.Dto;
@inject ISnackbar Snackbar
@inject HttpClient Http

<MudDialog>
    <DialogContent>
        <MudPaper @ondragenter="@SetDragClass" @ondragleave="@ClearDragClass" @ondragend="@ClearDragClass" Height="300px" Outlined="true" Class="@DragClass">
            @if (!Clearing)
            {
                <InputFile OnChange="OnInputFileChanged" multiple class="absolute mud-width-full mud-height-full overflow-hidden z-2" style="opacity:0;" />
            }
            <MudText Typo="Typo.h6">Drag and drop files here or click</MudText>
            @foreach (var file in _fileNames)
            {
                <MudChip Color="Color.Dark" Text="@file" />
            }
        </MudPaper>
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Upload" Disabled="@(!_fileNames.Any())" Color="Color.Primary" Variant="Variant.Filled">Upload</MudButton>
        <MudButton OnClick="Clear" Disabled="@(!_fileNames.Any())" Color="Color.Error" Variant="Variant.Filled">Clear</MudButton>
        <MudButton OnClick="Cancel">Cancel</MudButton>
    </DialogActions>
</MudDialog>
@code {
    [CascadingParameter] MudDialogInstance Dialog { get; set; } = null!;
    [Parameter] public long FolderId { get; set; }

    private bool Clearing = false;
    private static string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string DragClass = DefaultDragClass;

    private const long maxFileSize = 1024 * 1024 * 5;

    private List<IBrowserFile> _files = new();
    private List<string> _fileNames = new List<string>();

    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        var files = e.GetMultipleFiles();
        foreach (var file in files)
        {
            _files.Add(file);
            _fileNames.Add(file.Name);
        }
    }

    private async Task Clear()
    {
        Clearing = true;
        _fileNames.Clear();
        ClearDragClass();
        await Task.Delay(100);
        Clearing = false;
    }
    private async Task Upload()
    {
        using var content = new MultipartFormDataContent();
        var upload = false;
        List<FileUploadResult> uploadResults = new();

        foreach (var file in _files) {
            try
            {
                var fileContent = new StreamContent(file.OpenReadStream(maxFileSize));
                fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
                content.Add(content: fileContent, name: "\"files\"", fileName: file.Name);
                upload = true;
            }
            catch (Exception e)
            {
				//Logger.LogInformation($"{file.Name} cannot be uploaded: {e.Message}");
				//uploadResults.Add(new FileUploadResult
				//	{
				//		DisplayFileName = file.Name,
				//		ErrorCode = 6,
				//		Uploaded = false
				//	});
			}
        }
		
        if (upload)
        {
            var response = await Http.PostAsync($"Storage/UploadFiles?folderId={FolderId}", content);
            var newUploadResults = await response.Content.ReadFromJsonAsync<IList<FileUploadResult>>();

            if (newUploadResults != null)
            {
                uploadResults = uploadResults.Concat(newUploadResults).ToList();
            }
        }
		
		foreach (var uploadResult in uploadResults)
        {
			if(!uploadResult.Uploaded)
            {
                Snackbar.Add($"{uploadResult.DisplayFileName} Couldn't be uploaded", Severity.Error);
            }
        }

        Dialog.Close(DialogResult.Ok(true));
    }

    private void SetDragClass()
    {
        DragClass = $"{DefaultDragClass} mud-border-primary";
    }

    private void ClearDragClass()
    {
        DragClass = DefaultDragClass;
    }

    void Cancel() => Dialog.Cancel();
}